

\FloatBarrier

\chapter{The Bit Stream Layer}
\label{sec:bitstream}









\section{The \inl{Bitstream} abstraction}

As mentioned in Section~\ref{sec:packets},
the operation 
\lstinline{Bitstream_Read(stream,length)}
reads the next \lstinline{length} bits from the bitstream
\lstinline{stream}, and returns them as a \lstinline{uint64_t} value.
%
Its formal ACSL specification is shown in 
Listing~\ref{lst:Bitstream_Read spec}.
%
It requires \lstinline{stream}
%
\begin{itemize}
\item to point to a valid memory area 
	(requirement ``\lstinline{valid}''),
\item to adhere to its data type invariant
	(``\lstinline{invariant}''), and
\item not to be exhausted (``\lstinline{normal}'').
\end{itemize}
%
It is allowed to ---~and usually in fact will~--- modify the current bit
position within \lstinline{stream}, but it has to leave all other memory
unchanged (expressed by the ``\lstinline{assigns}'' clause).
%
After completion of the operation, 
%
\begin{itemize}
\item the current bit position has been increased accordingly
	(``\lstinline{ensures pos}''),
\item the return value equals, bit by bit, the stream between the
	current bit position on entry and that on exit
	(``\lstinline{changed}''),
\item in particular, all but the \lstinline{length} least significant
	bits of the return value are zero
	(``\lstinline{upper}''),
\item \lstinline{stream}'s total size remains unaffected
	(``\lstinline{size}''), and
\item so do all of its content bits
	(``\lstinline{unchanged}'').
\end{itemize}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires  valid:      Readable(stream);
  requires  invariant:  Invariant(stream, length);
  requires  normal:     Normal(stream, length);

  assigns   stream->bitpos;

  ensures   pos:        stream->bitpos == \old(stream->bitpos) + length;
  ensures   changed:    EqualBits(stream, \old(stream->bitpos), stream->bitpos, \result);
  ensures   upper:      UpperBitsNotSet(\result, length);
  ensures   size:       stream->size == \old(stream->size);
  ensures   unchanged:  Unchanged{Here,Old}(stream, 0, 8 * stream->size);
*/
uint64_t Bitstream_Read(Bitstream* stream, uint32_t length);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Read spec}Reading from a bitstream}
\end{listing}




The formal definitions of the ACSL predicates used
in \lstinline{Bitstream_Read}'s contract are given in
Listing~\ref{lst:Bitstream preds}; they build upon the internal
details of the \lstinline{Bitstream} data structure shown in
Listing~\ref{lst:Bitstream struct}.
%
Predicate \lstinline{Invariant} requires that a 
\lstinline{struct Bitstream}'s data area
doesn't overlap with the \lstinline{struct} itself, and that some
further, lower-level invariant holds (see Section~\ref{sec:bit sequences}
below).
%
In a similar way, predicates \lstinline{Normal} and
\lstinline{EqualBits} is reduced to a
lower-level predicate of the same 
name, respectively.\footnote{Frama-C allows for predicate overloading.}




\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
struct Bitstream
{
    uint8_t*  addr;     // start address of stream data
    uint32_t  size;     // length of stream data in bytes
    uint32_t  bitpos;   // current bit position within stream data
};
typedef struct Bitstream Bitstream;
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream struct}
	Details for the bitstream data structure}
\end{listing}





\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  predicate 
    Readable{L}(Bitstream* stream) = \valid(stream) &&
      \valid_read(stream->addr + (0..stream->size-1));

  predicate
    Writeable{L}(Bitstream* stream) = \valid(stream) &&
      \valid(stream->addr + (0..stream->size-1));

  predicate
    Invariant{L}(Bitstream* stream, integer length) =
      \separated(stream, stream->addr + (0..stream->size-1)) &&
      Invariant(stream->size, stream->bitpos, length);

  predicate
    Normal{L}(Bitstream* stream, integer length) =
      Normal(stream->size, stream->bitpos, length);

  predicate
    Unchanged{A,B}(Bitstream* stream, integer first, integer last) =
      \forall integer i;  first <= i < last ==>
        (\at(Bit8Array(stream->addr, i),A) <==>
         \at(Bit8Array(stream->addr, i),B));

  predicate
    EqualBits{A}(Bitstream* stream, integer first, integer last, uint64_t value) =
      EqualBits{A}(stream->addr, first, last, value);

*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream preds}
	ACSL predicates used in bitstream layer contracts}
\end{listing}




As a kind of constructor for
\lstinline{Bitstream}, we provide the operation \lstinline{Bitstream_Init},
shown with its contract in Listing~\ref{lst:Bitstream_Init}.
%
Moreover, we provide a test for exhaustion of a \lstinline{Bitstream},
shown in Listing~\ref{lst:Bitstream_Normal}.




\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:     Writeable(stream);
  requires bit_size:  8 * size <= UINT32_MAX;
  requires valid_pos: bitpos <= 8 * size;
  requires separated: \separated(addr + (0..size-1), stream);

  assigns  stream->addr, stream->size, stream->bitpos;

  ensures  addr:      stream->addr == addr;
  ensures  size:      stream->size == size;
  ensures  bitpos:    stream->bitpos == bitpos;
  ensures  invariant: Invariant(stream, 0);
*/
void Bitstream_Init(Bitstream* stream, uint8_t* addr, uint32_t size, uint32_t bitpos);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Init}Setting-up a bitstream}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:     Readable(stream);
  requires invariant: Invariant(stream, length);

  assigns \nothing;

  ensures  result:    \result <==> Normal(stream, length);
*/
int Bitstream_Normal(const Bitstream* stream, uint32_t length);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Normal}Testint a bitstream for exhaustion}
\end{listing}




\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:      Writeable(stream);
  requires invariant:  Invariant(stream, length);
  requires normal:     Normal(stream, length);
  requires upper:      UpperBitsNotSet(value, length);

  assigns stream->addr[0..stream->size - 1];
  assigns stream->bitpos;

  ensures  pos:        stream->bitpos == \old(stream->bitpos) + length;
  ensures  changed:    EqualBits(stream, \old(stream->bitpos), stream->bitpos, value);
  ensures  unchanged:  Unchanged{Here,Old}(stream, 0, \old(stream->bitpos));
  ensures  unchanged:  Unchanged{Here,Old}(stream, stream->bitpos, 8 * stream->size);
  ensures  size:       stream->size == \old(stream->size);
*/
void Bitstream_Write(Bitstream* stream, uint32_t length, uint64_t value)
{
    Bitwalker_Write(stream->addr, stream->size, stream->bitpos, length, value);
    //@ assert EqualBits(stream, stream->bitpos, stream->bitpos + length, value);

    stream->bitpos += length;
    //@ assert EqualBits(stream, \at(stream->bitpos,Pre), stream->bitpos, value);
}

\end{lstlisting}
\end{minipage}
\caption{Writing to a bitstream}
\end{listing}







\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]

\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]

\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]

\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]

\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}











\FloatBarrier

\section{Reading and writing bit sequences}
\label{sec:bit sequences}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
   predicate Readable{L}(uint8_t* addr, integer size) = \valid_read(addr + (0..size-1));

   predicate Writeable{L}(uint8_t* addr, integer size) = \valid(addr + (0..size-1));

   predicate Invariant{L}(integer size, integer bitpos, integer length) =
       8 * size <= UINT32_MAX         &&
       length <= 64                   &&
       bitpos + length <= UINT32_MAX;

    predicate Normal{L}(integer size, integer bitpos, integer length) =
       bitpos + length <= 8 * size;
*/
\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires  valid:      Readable(addr, size);
  requires  invariant:  Invariant(size, bitpos, length);
  requires  normal:     Normal(size, bitpos, length);

  assigns   \nothing;

  ensures   equal:      EqualBits(addr, bitpos, bitpos + length, \result);
  ensures   upper:      UpperBitsNotSet(\result, length);
*/
uint64_t Bitwalker_Read(uint8_t* addr, uint32_t size, uint32_t bitpos, uint32_t length);
\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:      Writeable(addr, size);
  requires invariant:  Invariant(size, bitpos, length);
  requires normal:     Normal(size, bitpos, length);
  requires upper:      UpperBitsNotSet(value, length);

  assigns addr[0..size-1];

  ensures  left:       Unchanged{Here,Old}(addr, 0, bitpos);
  ensures  middle:     EqualBits(addr, bitpos, bitpos + length, value);
  ensures  right:      Unchanged{Here,Old}(addr, bitpos + length, 8 * size);
*/
void Bitwalker_Write(uint8_t* addr, uint32_t size, uint32_t bitpos, uint32_t length, uint64_t value);
{
    /*@
      loop invariant bound:   bitpos <= i <= bitpos + length;
      loop invariant left:    Unchanged{Here,Pre}(addr, 0, bitpos);
      loop invariant middle:  EqualBits(addr, bitpos, i, value, length);
      loop invariant right:   Unchanged{Here,Pre}(addr, i, 8 * size);

      loop assigns  i, addr[0..size-1];
      loop variant  bitpos + length - i;
    */
    for (uint32_t i = bitpos; i < bitpos + length; ++i)
    {
        int flag = TestBit64(value, (64 - length) + (i - bitpos));
        SetBit8Array(addr, size, i, flag);
    }   
}

\end{lstlisting}
\end{minipage}
\caption{caption}
\end{listing}
















\FloatBarrier

\section{Formal verification}

