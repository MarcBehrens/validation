

\FloatBarrier

\chapter{The Bit Stream Layer}
\label{cha:bitstream}









\section{The \inl{Bitstream} abstraction}
\label{sec:bitstream}

As mentioned in Section~\ref{sec:packets},
the operations on packet data structures were implmented by 
operations that on a \lstinline{struct bitstream*} argument.
%
The latter are described in this section.

The operation 
\lstinline{Bitstream_Read(stream,length)}
reads the next \lstinline{length} bits from the bitstream
\lstinline{stream}, and returns them as a \lstinline{uint64_t} value.
%
Its formal ACSL specification is shown in 
Listing~\ref{lst:Bitstream_Read spec}.
%
It requires \lstinline{stream}
%
\begin{itemize}
\item to point to a valid memory area 
	(requirement ``\lstinline{valid}''),
\item to adhere to its data type invariant
	(``\lstinline{invariant}''), and
\item not to be exhausted (``\lstinline{normal}'').
\end{itemize}
%
It is allowed to ---~and usually in fact will~--- modify the current bit
position within \lstinline{stream}, but it has to leave all other memory
unchanged (expressed by the ``\lstinline{assigns}'' clause).
%
After completion of the operation, 
%
\begin{itemize}
\item the current bit position has been increased accordingly
	(``\lstinline{ensures pos}''),
\item the return value equals, bit by bit, the stream between the
	current bit position on entry and that on exit
	(``\lstinline{changed}''),
\item in particular, all but the \lstinline{length} least significant
	bits of the return value are zero
	(``\lstinline{upper}''),
%\fxfatal{explain UpperBitsNotSet}
\item \lstinline{stream}'s total size remains unaffected
	(``\lstinline{size}''), and
\item so do all of its content bits
	(``\lstinline{unchanged}'').
\end{itemize}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires  valid:      Readable(stream);
  requires  invariant:  Invariant(stream, length);
  requires  normal:     Normal(stream, length);

  assigns   stream->bitpos;

  ensures   pos:        stream->bitpos == \old(stream->bitpos) + length;
  ensures   changed:    EqualBits(stream, \old(stream->bitpos), stream->bitpos, \result);
  ensures   upper:      UpperBitsNotSet(\result, length);
  ensures   size:       stream->size == \old(stream->size);
  ensures   unchanged:  Unchanged{Here,Old}(stream, 0, 8 * stream->size);
*/
uint64_t Bitstream_Read(Bitstream* stream, uint32_t length);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Read spec}Reading from a bitstream}
\end{listing}





The formal definitions of the ACSL predicates used
in \lstinline{Bitstream_Read}'s contract are given in
Listing~\ref{lst:Bitstream preds}; they build upon the internal
details of the \lstinline{Bitstream} data structure shown in
Listing~\ref{lst:Bitstream struct}.
%
Predicate \lstinline{Invariant} requires that a 
\lstinline{struct Bitstream}'s data area
doesn't overlap with the \lstinline{struct} itself, and that some
further, lower-level invariant holds (see Section~\ref{sec:bit sequences}
below).
%
In a similar way, predicates \lstinline{Normal} and
\lstinline{EqualBits} is reduced to a
lower-level predicate of the same 
name, respectively.\footnote{Frama-C allows for predicate overloading.}
%
A clause \lstinline{Normal(size,bitpos,length)} requires \lstinline{bitpos} to be such
that at least \lstinline{length} more bits are available beyond it in a stream of byte-size
\lstinline{size}.\footnote{
	We tacitly assume that each stream has a multiple of 8 bits available.
	\fxfatal{unrealistic!?}
}
%
%\fxfatal{explain EqualBits}
A clause \lstinline{EqualBits(addr,first,last,value)} requires 
bits [\lstinline{first}\ldots\lstinline{last}) in
the byte array at \lstinline{addr} to coincide with the corresponding
least significant bits of \lstinline{value}, 
cf.~Figure~\ref{fig:EqualBits correspondance}.


\begin{figure}
\begin{center}
\vspace*{2cm}
--- Insert drawing ---
\vspace*{2cm}
\caption{\label{fig:EqualBits correspondance}
	Bit coincidences required by \lstinline{EqualBits}}
\end{center}
\end{figure}




\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
struct Bitstream
{
    uint8_t*  addr;     // start address of stream data
    uint32_t  size;     // length of stream data in bytes
    uint32_t  bitpos;   // current bit position within stream data
};
typedef struct Bitstream Bitstream;
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream struct}
	Details for the bitstream data structure}
\end{listing}





\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  predicate 
    Readable{L}(Bitstream* stream) = \valid(stream) &&
      \valid_read(stream->addr + (0..stream->size-1));

  predicate
    Writeable{L}(Bitstream* stream) = \valid(stream) &&
      \valid(stream->addr + (0..stream->size-1));

  predicate
    Invariant{L}(Bitstream* stream, integer length) =
      \separated(stream, stream->addr + (0..stream->size-1)) &&
      Invariant(stream->size, stream->bitpos, length);

  predicate
    Normal{L}(Bitstream* stream, integer length) =
      Normal(stream->size, stream->bitpos, length);

  predicate
    Unchanged{A,B}(Bitstream* stream, integer first, integer last) =
      \forall integer i;  first <= i < last ==>
        (\at(Bit8Array(stream->addr, i),A) <==>
         \at(Bit8Array(stream->addr, i),B));

  predicate
    EqualBits{A}(Bitstream* stream, integer first, integer last, uint64_t value) =
      EqualBits{A}(stream->addr, first, last, value);

*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream preds}
	ACSL predicates used in bitstream layer contracts}
\end{listing}




As a kind of constructor for
\lstinline{Bitstream}, we provide the operation \lstinline{Bitstream_Init},
shown with its contract in Listing~\ref{lst:Bitstream_Init}.
%
Moreover, we provide a test for exhaustion of a \lstinline{Bitstream},
shown in Listing~\ref{lst:Bitstream_Normal}.




\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:     Writeable(stream);
  requires bit_size:  8 * size <= UINT32_MAX;
  requires valid_pos: bitpos <= 8 * size;
  requires separated: \separated(addr + (0..size-1), stream);

  assigns  stream->addr, stream->size, stream->bitpos;

  ensures  addr:      stream->addr == addr;
  ensures  size:      stream->size == size;
  ensures  bitpos:    stream->bitpos == bitpos;
  ensures  invariant: Invariant(stream, 0);
*/
void Bitstream_Init(Bitstream* stream, uint8_t* addr, uint32_t size, uint32_t bitpos);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Init}Setting-up a bitstream}
\end{listing}



\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:     Readable(stream);
  requires invariant: Invariant(stream, length);

  assigns \nothing;

  ensures  result:    \result <==> Normal(stream, length);
*/
int Bitstream_Normal(const Bitstream* stream, uint32_t length);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Normal}Testing a bitstream for exhaustion}
\end{listing}





Listing~\ref{lst:Bitstream_Write impl} shows contract of
\lstinline{Bitstream_Write}, and moreover exemplfies its implementation.

Most parts of the contract are quite similar to that of \lstinline{Bitstream_Read} in
Listing~\ref{lst:Bitstream_Read spec}.
%
Differences are the following:
\begin{itemize}
\item We require that the \lstinline{value} to be written fits into the specified
	\lstinline{length}, i.e.\ its unused most significant bits are zero (requirement
	``\lstinline{upper}'').
\item The operation is allowed to change the contents of the bitstream 
	(first \lstinline{assigns} clause) in addition to the streams current bit
	position (second \lstinline{assigns} clause), but no other memory locations.
\item Since we couldn't specify in the \lstinline{assigns} clauses 
	which bits exactly are allowed to be modified, we give the details in two
	\lstinline{ensures} clauses named ``\lstinline{unchanged}'':
	All bits before the stream's \lstinline{bitpos} on operation entry, and after
	its \lstinline{bitpos} on exit, must remain unchanged.
\end{itemize}

The implementation just employs the lower-level operation \lstinline{Bitwalker_Write} to
write the bits, and appropriately updates the \lstinline{stream}'s \lstinline{bitpos}.
%
Two assertions were needed to help the provers establishing that \lstinline{value}'s
bits are actually written to \lstinline{stream}'s data array by
\lstinline{Bitwalker_Write}, and that they aren't destoyed during \lstinline{bitpos}
update.




\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:      Writeable(stream);
  requires invariant:  Invariant(stream, length);
  requires normal:     Normal(stream, length);
  requires upper:      UpperBitsNotSet(value, length);

  assigns stream->addr[0..stream->size - 1];
  assigns stream->bitpos;

  ensures  pos:        stream->bitpos == \old(stream->bitpos) + length;
  ensures  changed:    EqualBits(stream, \old(stream->bitpos), stream->bitpos, value);
  ensures  unchanged:  Unchanged{Here,Old}(stream, 0, \old(stream->bitpos));
  ensures  unchanged:  Unchanged{Here,Old}(stream, stream->bitpos, 8 * stream->size);
  ensures  size:       stream->size == \old(stream->size);
*/
void Bitstream_Write(Bitstream* stream, uint32_t length, uint64_t value)
{
    Bitwalker_Write(stream->addr, stream->size, stream->bitpos, length, value);
    //@ assert EqualBits(stream, stream->bitpos, stream->bitpos + length, value);

    stream->bitpos += length;
    //@ assert EqualBits(stream, \at(stream->bitpos,Pre), stream->bitpos, value);
}

\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitstream_Write impl}Writing to a bitstream}
\end{listing}














\FloatBarrier

\section{Reading and writing bit sequences}
\label{sec:bit sequences}

In this section, we describe the operations that handle plain bit sequences.
%
They are used to implement the \lstinline{struct bitstream*} operations for
Section~\ref{sec:bitstream}.

The operation \lstinline{Bitwalker_Read(addr,size,bitpos,length)} reads
\lstinline{length} bits starting at \lstinline{bitpos} from the array
\lstinline{addr} of byte-size \lstinline{size}, and returns them as a
\lstinline{uint64_t} value.
%
Its ACSL contract is shown in Listing~\ref{lst:Bitwalker_Read spec}.
%
It requires
%
\begin{itemize}
\item all bytes of the \lstinline{addr} array to be accessible for read
	(requirement ``\lstinline{valid}''),
\item some data type invariants to hold
	(``\lstinline{invariant}''), viz.\
	%
	\begin{itemize}
	\item the total number of array bits to fit into a \lstinline{uint32_t},
	\item the result value to fit into a \lstinline{uint64_t},
	\item the end bit position ---~and hence also the start bit position
		\lstinline{bitpos} and \lstinline{length}~---
		to fit into a \lstinline{uint32_t}, 
	\end{itemize}
	and
\item the bit range [\lstinline{bitpos}\ldots\lstinline{bitpos}+\lstinline{length})
	to fit into the array at \lstinline{addr}
	(``\lstinline{normal}'').
\end{itemize}
%
The operation is not allowed to modify any (non-local) memory (expressed by the
``\lstinline{assigns}'' clause).
%
After completion of the operation,
%
\begin{itemize}
\item the return value shall coincide bit by bit with the specified range of the
	\lstinline{addr} array (``\lstinline{ensures equal}''), and
\item in particular, all but the least significant \lstinline{length} bits of the return
	value shall be zero (``\lstinline{upper}'').
\end{itemize}







\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires  valid:      Readable(addr, size);
  requires  invariant:  Invariant(size, bitpos, length);
  requires  normal:     Normal(size, bitpos, length);

  assigns   \nothing;

  ensures   equal:      EqualBits(addr, bitpos, bitpos + length, \result);
  ensures   upper:      UpperBitsNotSet(\result, length);
*/
uint64_t Bitwalker_Read(uint8_t* addr, uint32_t size, uint32_t bitpos, uint32_t length);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitwalker_Read spec}Reading a bit sequence}
\end{listing}





The formal definitions of the used ACSL predicates are given in
Listing~\ref{lst:Bitsequence preds}.
%
Again, the tacit assumption that the array contains sensible data upto its very last bit
is used in predicate \lstinline{Normal}.









\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
   predicate Readable{L}(uint8_t* addr, integer size) = \valid_read(addr + (0..size-1));

   predicate Writeable{L}(uint8_t* addr, integer size) = \valid(addr + (0..size-1));

   predicate Invariant{L}(integer size, integer bitpos, integer length) =
       8 * size <= UINT32_MAX         &&
       length <= 64                   &&
       bitpos + length <= UINT32_MAX;

    predicate Normal{L}(integer size, integer bitpos, integer length) =
       bitpos + length <= 8 * size;
*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:Bitsequence preds} ACSL predicates used in bitsequence layer contracts}
\end{listing}





Listing~\ref{Bitwalker_Write spec} shows the contract, and the implementation, of
\lstinline{Bitwalker_Write}.
%
The following peculiarities are observed when the former is
compared to \lstinline{Bitwalker_Read}'s contract:
%
\begin{itemize}
\item We require that the \lstinline{value} to be written fits into the specifiec
	\lstinline{length}, i.e.\ all but its \lstinline{length} least significant bits are
	zero (requirement ``\lstinline{upper}'').
\item The operation may modify the data array at \lstinline{addr}, but nothing else.
\item Again, we give the details of which data bits exactly
	are allowed to be changed in two
	\lstinline{ensures} clauses, named ``\lstinline{left}'' and
	``\lstinline{right}'', and requiring all bits before \lstinline{bitpos} and after
	\lstinline{bitpos+length} to remain unchanged, respectively.
\end{itemize}

In the implementation, which is shown here as an example, we used the straight-forward
algorithm that takes a bit from \lstinline{value} and places it into the \lstinline{addr}
array, bit by bit.
%
In order for the provers to establish that algorithm's correctness, we had to provide a
total of six ACSL clauses about the loop:
%
\begin{itemize}
\item The loop variable, \lstinline{i}, always ranges in the interval
	[\lstinline{bitpos}\ldots\lstinline{bitpos+length}] 
	--- loop invariant ``\lstinline{bound}''.
	%
	Note that the highest value is actually taken,
	viz.\ on exit of the loop body in the last iteration,
	subsequently causing the loop to terminate.
\item The bits before \lstinline{bitpos}, and after \lstinline{bitpos+length}
	remain as they were on operation entry --- invariant
	``\lstinline{left}'' and ``\lstinline{right}'', respectively.
\item In the \lstinline{i}th iteration, the bits
	[\lstinline{bitpos}\ldots\lstinline{bitpos+i}) agree with the least significant
	\lstinline{i} bits of \lstinline{value} --- invariant ``\lstinline{middle}''.
\item The loop code is allowed to modify the variable \lstinline{i}, and the whole array
	at \lstinline{addr}, but nothing else --- \lstinline{loop assigns} clause.
\item The value of the integer
	expression \lstinline{bitpos+length-i} is non-negative thoughout
	the whole loop execution, but is decreased in every iteration 
	--- \lstinline{loop variant} clause.
	%
	Therefore, the loop is guaranteed to terminate eventually.
\end{itemize}









\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
  requires valid:      Writeable(addr, size);
  requires invariant:  Invariant(size, bitpos, length);
  requires normal:     Normal(size, bitpos, length);
  requires upper:      UpperBitsNotSet(value, length);

  assigns addr[0..size-1];

  ensures  left:       Unchanged{Here,Old}(addr, 0, bitpos);
  ensures  middle:     EqualBits(addr, bitpos, bitpos + length, value);
  ensures  right:      Unchanged{Here,Old}(addr, bitpos + length, 8 * size);
*/
void Bitwalker_Write(uint8_t* addr, uint32_t size, uint32_t bitpos, uint32_t length, uint64_t value);
{
    /*@
      loop invariant bound:   bitpos <= i <= bitpos + length;
      loop invariant left:    Unchanged{Here,Pre}(addr, 0, bitpos);
      loop invariant middle:  EqualBits(addr, bitpos, i, value, length);
      loop invariant right:   Unchanged{Here,Pre}(addr, i, 8 * size);

      loop assigns  i, addr[0..size-1];
      loop variant  bitpos + length - i;
    */
    for (uint32_t i = bitpos; i < bitpos + length; ++i)
    {
        int flag = TestBit64(value, (64 - length) + (i - bitpos));
        SetBit8Array(addr, size, i, flag);
    }   
}

\end{lstlisting}
\end{minipage}
\caption{\label{Bitwalker_Write spec}Writing a bit sequence}
\end{listing}





The implementation of the bit sequence operations is based
on operations to write and to read a single bit.
%
The details of the latter, as well as of the predicates used in their contracts,
are given in Appendix~\ref{cha:low-level bitstream}.














% deleted here, sonce an own chapter is devoted to it (jb)
%\section{Formal verification}

