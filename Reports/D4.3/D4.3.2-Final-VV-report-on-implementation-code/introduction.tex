
\chapter{Introduction}

In this intermediate report we describe the activities to formally verify
the correctness of parts of the software developed in the OpenETCS project.

While major parts of the functionality of {Subset 026} are modelled in 
higher-level languages, there is also a substantial part of \emph{supporting} software
that is developed in the~C programming language.

In this document we report about results on the verification of that C~code.
In particular, we report on the use of static analysis methods (including formal methods)
on C~code that has been developed by the project partner Siemens.

\begin{figure}[hbt]
\begin{center}
\includegraphics[width=0.95\textwidth]{figures/scope-of-formalization.pdf}
\caption{\label{fig:scope-of-formalization} Scope of formal methods with in OpenETCS}
\end{center}
\end{figure}

Figure~\ref{fig:scope-of-formalization} outlines the roles of formal methods
within the OpenETCS project.
What this figure shall convey is that even a subsystem such as described by
\emph{Subset 026} of the ETCS specification
is usually too complex to be completely formally specified.
Therefore, \emph{semi-formal modelling techniques} and \emph{tests} and 
\emph{simulations} play a crucial role to verify that the implementation
satisfies its specification.
However, for clearly defined modules and select system properties, formal methods
can well be applied to establish the correctness of an implementation.

Figure~\ref{fig:scope-of-code-verification} shows slightly more detailed
the OpenETCS software.
The report at hand is limited to the parts encapsulated by C software encapsulated 
in a \dbox{dashed box}.

\clearpage

\begin{figure}[hbt]
\begin{center}
\includegraphics[width=0.95\textheight,angle=90]{figures/OpenETCS-Stack.pdf}
\caption{\label{fig:scope-of-code-verification} Scope of code verification}
\end{center}
\end{figure}

\FloatBarrier

\section{Software layers}

Figure~\ref{fig:software-layers} shows the layer structure of the OpenETCS C~code.
The OpenETCS decoder\slash enocder is a collection of data structures and associated functions
for reading and writing ETCS packets from\slash to a bit stream.

\begin{figure}[hbt]
\begin{center}
\includegraphics[width=1.0\textwidth]{figures/software-layers.pdf}
\caption{\label{fig:software-layers} Software layers of the OpenETCS C~code}
\end{center}
\end{figure}

\FloatBarrier

In order to fulfill their task the decoder and encoder function rely on an
implementation of bit streams in C.
The \inl{Bitstream} package in turn is built on top of the so-called \emph{bitwalker} layer.
In order to accomplish the task of formal verification of these layers 
we also provided several functions that read and write individual bits for basic C~types.

The main achievement that we present in this report are the results
on the formal specification and formal specification of the various software layers 
in Figure~\ref{fig:software-layers}.

This report is result of the joint work of many OpenETCS partners, notably:

\begin{itemize}
\item CEA LIST
\item DLR
\item Fraunhofer FOKUS
\item Siemens
\item SQS
\end{itemize}

The formal analyses contribute to the ultimate verification goals, which are the following:

\begin{enumerate}
\item provide evidence that both the generated and a handwritten C~code satisfies 
      accepted quality standards
\item develop a formal specification for Subset~026 functionality
\item verify with \framacwp that the software satisfies its formal specification
\item show that the software does not raise runtime errors
\end{enumerate}

\section{Structure of this document}

Chapter~\ref{sec:frama-c} gives a short overview on the \framacwp tool
that plays a central role in the verification of OpenETCS C~code.
Here we also try to rectify some misunderstandings about formal verification
that we have encountered in our work.

In Chapter~\ref{sec:formal-verification} we analyze
the functions \peek and \poke from the Bitwalker core and
\begin{enumerate}
\item formally specify the
      expected functional behavior in the \acsl specification language of {Frama-C}
      and
\item report on the formal proof 
	that these
      C~functions do not raise runtime errors when called according to their
      formal specification, established using 
      the {Frama-C} verification platform.
\end{enumerate}

So far only a part of Siemens' \bitwalker has been formalized and verified.
In the process of this work several enhancements for the \framac verification platform
have been identified and reported to the developers at {CEA LIST}.

In Chapter~\ref{sec:static-analysis}, we report about the results of
SQS' application of a broad range of static analysis tools on the \bitwalker. 
In contrast to \framac, these tools cannot exhaustively
detect all potential defects of a given kind.
Nevertheless, these they are very useful at finding well-known quality deficiencies that
might occur in C or \CC\ software.

In Chapter~\ref{sec:conclusions}, we draw conclusions from this preliminary work
and outline the next steps in our verification efforts.

