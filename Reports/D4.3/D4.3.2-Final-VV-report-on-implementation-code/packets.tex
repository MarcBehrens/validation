

\chapter{ETCS data packets}
\label{sec:packets}

\section{Formal specification of \inl{AdhesionFactor}}
\label{sec:adhesionfactor}

\subsection{\inl{AdhesionFactor} in ETCS}
\label{sec:adhesionfactor-etcs}

\fxfatal{add table from chapter 7}

\subsection{The type \inl{AdhesionFactor}}
\label{sec:adhesionfactor-type}

Listing~\ref{lst:adhesionfactor-type} shows the definition of type
\inl{AdhesionFactor} as it is generated from the ETCS specification shown in Section~\ref{sec:adhesionfactor-etcs}.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
struct AdhesionFactor
{
    PacketHeader header;

    // TransmissionMedia=Any
    // This packet is used when the trackside requests a change of
    // the adhesion factor to be used in the brake model.
    // Packet Number = 71

    uint64_t  Q_DIR;            // # 2
    uint64_t  L_PACKET;         // # 13
    uint64_t  Q_SCALE;          // # 2
    uint64_t  D_ADHESION;       // # 15
    uint64_t  L_ADHESION;       // # 15
    uint64_t  M_ADHESION;       // # 1
};

typedef struct AdhesionFactor AdhesionFactor;
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-type}Defintion of the type \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier  % forces the output of listings/tables

\subsection{\acsl predicates \inl{AdhesionFactor}}
\label{sec:adhesionfactor-predicates-bitsize}

Listing~\ref{lst:adhesionfactor-predicates-bitsize} shows the definition of
the logic functions \inl{BitSize} and \inl{MaxBitSize} for \inl{AdhesionFactor}.
The former function uses a macro that contains the size of \inl{AdhesionFactor} in bits.
The functions are used in Listing~\ref{lst:adhesionfactor-decodebit} and
Listing~\ref{lst:adhesionfactor-encodebit} where the overloading of the
logic predicates allows for a more generic \acsl contract for the \inl{EncodeBit} and
\inl{DecodeBit} functions.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    logic integer BitSize{L}(AdhesionFactor* p) = ADHESIONFACTOR_BITSIZE;

    logic integer MaxBitSize{L}(AdhesionFactor* p) = BitSize(p);
*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-predicates-bitsize}Definition of the \inl{BitSize} predicates for \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\label{sec:adhesionfactor-predicates-invariant}

Listing~\ref{lst:adhesionfactor-predicates-invariant} shows the definition of the
\inl{Invariant} predicate for \inl{AdhesionFactor}.
The predicate is the conjunction of the (trivial) \inl{Invariant(uint64_t)} predicates
of all members of on object of type \inl{AdhesionFactor}.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    predicate Invariant(AdhesionFactor* p) =
      Invariant(p->Q_DIR)             &&
      Invariant(p->L_PACKET)          &&
      Invariant(p->Q_SCALE)           &&
      Invariant(p->D_ADHESION)        &&
      Invariant(p->L_ADHESION)        &&
      Invariant(p->M_ADHESION);
*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-predicates-invariant}Definition of the \inl{Invariant} predicate for \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\label{sec:adhesionfactor-predicates-upperbitsnotset}

\fxfatal{Make sure that there is an explanation of UpperBitsNotSet in Chapter~\ref{cha:bitstream}}

Listing~\ref{lst:adhesionfactor-predicates-upperbitsnotset} shows the definition
of the \inl{UpperBitsNotSet} predicate for \inl{AdhesionFactor}.
The predicate \inl{UpperBitsNotSet(AdhesionFactor*)} evaluates to true
if and only if the values of all members of \inl{AdhesionFactor}
fit into their assigned numbers of bits.
This functionality is ensured by the conjunction of the \inl{UpperBitsNotSet(uint64_t, uint32_t)} predicate,
which is explained in Chapter~\ref{cha:bitstream}, for all members of \inl{AdhesionFactor}.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    predicate UpperBitsNotSet(AdhesionFactor* p) =
      UpperBitsNotSet(p->Q_DIR,            2)   &&
      UpperBitsNotSet(p->L_PACKET,         13)  &&
      UpperBitsNotSet(p->Q_SCALE,          2)   &&
      UpperBitsNotSet(p->D_ADHESION,       15)  &&
      UpperBitsNotSet(p->L_ADHESION,       15)  &&
      UpperBitsNotSet(p->M_ADHESION,       1);
*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-predicates-upperbitsnotset}Definition of the \inl{UpperBitsNotSet} predicate for \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\label{sec:adhesionfactor-predicates-separated}

Listing~\ref{lst:adhesionfactor-predicates-separated} shows the definition of 
predicate  \inl{Separated} for \inl{AdhesionFactor}.
The predicate \inl{Separated(stream, p)} is true if and only if 
the two objects \inl{*stream} and \inl{*p} do not overlap in memory.
Thus, writing into the stream will not change \inl{*p} and vice versa.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    predicate Separated(Bitstream* stream, AdhesionFactor* p) =
      \separated(stream, p) &&
      \separated(stream->addr + (0..stream->size-1), p);
*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-predicates-separated}Definition of the \inl{Separated} predicate for \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\label{sec:adhesionfactor-predicates-equalbits}

\fxfatal{Make sure that there is an explanation of EqualBits in Chapter~\ref{cha:bitstream}}

Listing~\ref{lst:adhesionfactor-predicates-equalbits} shows the definition of the
\inl{EqualBits} predicate for \inl{AdhesionFactor}.
Based on the ETCS specification, this predicate describes a
relationship between the bits of the individual members
of an object of type \inl{AdhesionFactor} and those of a bit stream.
This predicate will be used to formally describe the transfer of bits
from a bit stream to an object of type \inl{AdhesionFactor} and vice versa.
The definition of the predicate \inl{EqualBits(AdhesionFactor*)} uses
the predicate \inl{EqualBits(uint64_t)}, which is explained
in Chapter~\ref{cha:bitstream}.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    predicate EqualBits(Bitstream* stream, integer pos, AdhesionFactor* p) =
      EqualBits(stream, pos,       pos + 2,   p->Q_DIR)             &&
      EqualBits(stream, pos + 2,   pos + 15,  p->L_PACKET)          &&
      EqualBits(stream, pos + 15,  pos + 17,  p->Q_SCALE)           &&
      EqualBits(stream, pos + 17,  pos + 32,  p->D_ADHESION)        &&
      EqualBits(stream, pos + 32,  pos + 47,  p->L_ADHESION)        &&
      EqualBits(stream, pos + 47,  pos + 48,  p->M_ADHESION);
*/
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-predicates-equalbits}Definition of the \inl{EqualBits} predicate for \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\subsection{Formal specification of \inl{AdhesionFactor_UpperBitsNotSet}}
\label{sec:adhesionfactor-upperbitsnotset}

Listing~\ref{lst:adhesionfactor-upperbitsnotset} shows the contract of the \inl{UpperBitsNotSet}
function for \inl{AdhesionFactor}.
The function contract includes the \inl{requires} clauses, labeled \inl{valid} and \inl{invariant}.
These limit the significance of the \inl{ensures} and \inl{assigns} clauses to
the \inl{AdhesionFactor} objects that also satisfy the \inl{requires} clauses.
The \inl{valid} clause only evaluates to true if the \inl{*p} is a valid pointer.
The \inl{invariant} clause requires \inl{Invariant(p)} to evaluate to true.
The \inl{Invariant(AdhesionFactor*)} predicate is explained
in Section~\ref{sec:adhesionfactor-predicates-invariant}.
The contract also inlcudes a statement on the return value of the function, labeled \inl{result}.
This clause ensures that the function's return value for \inl{AdhesionFactor* p}
matches the evaluation of the predicate \inl{UpperBitsNotSet(p)}
from Section~\ref{sec:adhesionfactor-predicates-upperbitsnotset}.
With the \inl{assigns \\nothing} clause the contract furthermore
specifies that this function has no side effects.

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    requires valid:      \valid_read(p);
    requires invariant:  Invariant(p);

    assigns \nothing;

    ensures result:  \result <==> UpperBitsNotSet(p);
*/
int AdhesionFactor_UpperBitsNotSet(const AdhesionFactor* p);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-upperbitsnotset}Contract for \inl{UpperBitsNotSet} function of \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\fxfatal{Refer to a more accurate label instead of cha:bitstream}

\subsection{Formal specification of \inl{AdhesionFactor_DecodeBit}}
\label{sec:adhesionfactor-decodebit}

Listing~\ref{lst:adhesionfactor-decodebit} shows the contract for the \inl{DecodeBit} function
of \inl{AdhesionFactor}. The contract contains two behaviors which cover all cases.
The \inl{normal_case} behavior occurs if the \inl{Bitstream} contains enough bits
to fill an \inl{AdhesionFactor} instance. The \inl{error_case} behavior occurs if the \inl{Bitstream}
becomes exhausted, before a complete \inl{AdhesionFactor} instance can be read.
The distinctive for the two behavior is the outcome  of the \inl{Normal} predicate call
for the \inl{Bitstream}, which is explained in Chapter~\ref{cha:bitstream}. 

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    requires valid_stream:      Readable(stream);
    requires stream_invariant:  Invariant(stream, MaxBitSize(p));
    requires valid_package:     \valid(p);
    requires separation:        Separated(stream, p);

    assigns stream->bitpos;
    assigns *p;

    ensures unchanged:          Unchanged{Here,Old}(stream, 0, 8*stream->size);

    behavior normal_case:
      assumes Normal{Pre}(stream, MaxBitSize(p));

      assigns stream->bitpos;
      assigns *p;

      ensures invariant:  Invariant(p);
      ensures result:     \result == 1;
      ensures increment:  stream->bitpos == \old(stream->bitpos) + BitSize(p);
      ensures equal:      EqualBits(stream, \old(stream->bitpos), p);
      ensures upper:      UpperBitsNotSet(p);

    behavior error_case:
      assumes !Normal{Pre}(stream, MaxBitSize(p));

      assigns \nothing;

      ensures result: \result == 0;

    complete behaviors;
    disjoint behaviors;
*/
int AdhesionFactor_EncodeBit(const AdhesionFactor* p, Bitstream* stream);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-decodebit}Contract for \inl{DecodeBit} function of \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\subsection{Formal specification of \inl{AdhesionFactor_EncodeBit}}
\label{sec:adhesionfactor-encodebit}

\begin{listing}[hbt]
\begin{minipage}{0.99\textwidth}
\begin{lstlisting}[style=acsl-block]
/*@
    requires valid_stream:      Writeable(stream);
    requires stream_invariant:  Invariant(stream, MaxBitSize(p));
    requires valid_package:     \valid_read(p);
    requires invariant:         Invariant(p);
    requires separation:        Separated(stream, p);

    assigns stream->bitpos;
    assigns stream->addr[0..(stream->size-1)];

    behavior normal_case:
      assumes Normal{Pre}(stream, MaxBitSize(p)) && UpperBitsNotSet{Pre}(p);

      assigns stream->bitpos;
      assigns stream->addr[0..(stream->size-1)];

      ensures result:     \result == 1;
      ensures increment:  stream->bitpos == \old(stream->bitpos) + BitSize(p);
      ensures left:       Unchanged{Here,Old}(stream, 0, \old(stream->bitpos));
      ensures middle:     EqualBits(stream, \old(stream->bitpos), p);
      ensures right:      Unchanged{Here,Old}(stream, stream->bitpos, 8 * stream->size);

    behavior values_too_big:
      assumes Normal{Pre}(stream, MaxBitSize(p)) && !UpperBitsNotSet{Pre}(p);

      assigns \nothing;

      ensures result:        \result == -2;

    behavior invalid_bit_sequence:
      assumes !Normal{Pre}(stream, MaxBitSize(p));

      assigns \nothing;

      ensures result:       \result == -1;

    complete behaviors;
    disjoint behaviors;
*/
int AdhesionFactor_DecodeBit(AdhesionFactor* p, Bitstream* stream);
\end{lstlisting}
\end{minipage}
\caption{\label{lst:adhesionfactor-encodebit}Contract for \inl{EncodeBit} function of \inl{AdhesionFactor}}
\end{listing}

\FloatBarrier

\subsection{Formal verification of \inl{AdhesionFactor}}

\section{Formal specification of other packets}

